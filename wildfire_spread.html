<html>
    <style>
        body {
            padding: 40px;
            margin: 0px;
            background: #263238;
            color: rgba(255, 255, 255, 0.75);
            font-family: "Courier";
        }

        canvas {
            display: block;
            position: relative;
            margin-left: auto;
            margin-right: auto;
            border-radius: 60px;
            border: 4px solid rgba(255, 255, 255, 0.75);
        }

        #text-container {
            margin-left: auto;
            margin-right: auto;
            width: 928px;
            margin-bottom: 40px;
        }

        #title {
            text-align: center;
            margin-bottom: 40px;
            font-size: 20px;
        }

        span {
            font-weight: bold;
        }
    </style>
    <script>
        const IMAGE_WIDTH = 928;
        const IMAGE_HEIGHT = 800;

        const STATE_EMPTY = 0;
        const STATE_TREE = STATE_EMPTY + 1;
        const STATE_BURNING = STATE_TREE + 1;
        const STATE_BURNED = STATE_BURNING + 1;

        const MAX_HUE_DELTA = 36;
        const BURNABLE_AREA_HUE = 90;
        const DARKEN_DELTA = 128;

        const RANDOM_BURN_RATE_PROBABILITY = 0.000002368; // From https://iopscience.iop.org/article/10.1088/1367-2630/4/1/317
        const TRANSMISSION_PROBABILITY = 0.3;
        const TREE_REGENERATION_PROBABILITY = 0.592;

        const IMAGE_URL = 'https://petapixel.com/assets/uploads/2017/01/large2014.jpg';

        let originalPatch;
        let context;
        let state = Array(IMAGE_WIDTH);
    
        function rgb2hsv(r, g, b) {
            let rabs, gabs, babs, rr, gg, bb, h, s, v, diff, diffc, percentRoundFn;
            rabs = r / 255;
            gabs = g / 255;
            babs = b / 255;
            v = Math.max(rabs, gabs, babs),
            diff = v - Math.min(rabs, gabs, babs);
            diffc = c => (v - c) / 6 / diff + 1 / 2;
            percentRoundFn = num => Math.round(num * 100) / 100;
            if (diff == 0) {
                h = s = 0;
            } else {
                s = diff / v;
                rr = diffc(rabs);
                gg = diffc(gabs);
                bb = diffc(babs);

                if (rabs === v) {
                    h = bb - gg;
                } else if (gabs === v) {
                    h = (1 / 3) + rr - bb;
                } else if (babs === v) {
                    h = (2 / 3) + gg - rr;
                }
                if (h < 0) {
                    h += 1;
                }else if (h > 1) {
                    h -= 1;
                }
            }
            return {
                h: Math.round(h * 360),
                s: percentRoundFn(s * 100),
                v: percentRoundFn(v * 100)
            };
        }

        function onLoad() {
            let canvas = document.getElementById("canvas");
            context = canvas.getContext("2d");
            let image = new Image();
            image.onload = function() {
                context.drawImage(image, 0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
                originalPatch = context.getImageData(
                    0,
                    0,
                    IMAGE_WIDTH,
                    IMAGE_HEIGHT);

                for (let x = 0; x < IMAGE_WIDTH; x++) {
                    state[x] = Array(IMAGE_HEIGHT);
                    for (let y = 0; y < IMAGE_HEIGHT; y++) {
                        let hsv = hsvOfPixel(x, y)
                        if (BURNABLE_AREA_HUE - MAX_HUE_DELTA < hsv.h &&
                            hsv.h < BURNABLE_AREA_HUE + MAX_HUE_DELTA) {
                            state[x][y] = STATE_TREE;
                        } else {
                            state[x][y] = STATE_EMPTY;
                        }
                    }
                }
                setTimeout(runLoop, 100);
            };
            image.crossOrigin = '';
            image.src = IMAGE_URL;
            populateHtml();
        }

        function hsvOfPixel(x, y) {
            let patchImageDataStartIndex = 4 * (y * IMAGE_WIDTH + x);
            let red = originalPatch.data[patchImageDataStartIndex];
            let green = originalPatch.data[patchImageDataStartIndex + 1];
            let blue = originalPatch.data[patchImageDataStartIndex + 2];
            let hsv = rgb2hsv(red, green, blue);
            return hsv;
        }

        function runLoop() {
            render();
            let newState = Array(IMAGE_WIDTH);
            for (let x = 0; x < IMAGE_WIDTH; x++) {
                newState[x] = Array(IMAGE_HEIGHT);
                for (let y = 0; y < IMAGE_HEIGHT; y++) {
                    if (state[x][y] == STATE_BURNING) {
                        newState[x][y] = STATE_BURNED;
                    } else if (state[x][y] == STATE_TREE) {
                        if (areAnyNeighborsBurning(x, y)) {
                            randomValue = Math.random();
                            let treeDensity = Math.abs(hsvOfPixel(x, y).h - BURNABLE_AREA_HUE) / MAX_HUE_DELTA;
                            if (randomValue < treeDensity * TRANSMISSION_PROBABILITY) {
                                newState[x][y] = STATE_BURNING;
                            } else {
                                newState[x][y] = STATE_TREE;
                            }
                        } else {
                            randomValue = Math.random();
                            if (randomValue < RANDOM_BURN_RATE_PROBABILITY) {
                                newState[x][y] = STATE_BURNING;
                            } else {
                                newState[x][y] = STATE_TREE;
                            }
                        }
                    } else if (state[x][y] == STATE_BURNED) {
                        if (randomValue < TREE_REGENERATION_PROBABILITY) {
                            newState[x][y] = STATE_TREE;
                        } else {
                            newState[x][y] = STATE_BURNED;
                        }
                    } else {
                        newState[x][y] = state[x][y];
                    }
                }
            }
            state = newState;
            setTimeout(runLoop, 100);
        }

        function render() {
            let buffer = new Uint8ClampedArray(IMAGE_WIDTH * IMAGE_HEIGHT * 4); 
            for (let x = 0; x < IMAGE_WIDTH; x++) {
                for (let y = 0; y < IMAGE_HEIGHT; y++) {
                    let imageDataIndex = 4 * (y * IMAGE_WIDTH + x);
                    if (state[x][y] == STATE_BURNING) {
                        buffer[imageDataIndex] = 255;
                        buffer[imageDataIndex + 1] = 0;
                        buffer[imageDataIndex + 2] = 0;
                        buffer[imageDataIndex + 3] = originalPatch.data[imageDataIndex + 3];
                    } else if (state[x][y] == STATE_BURNED) {
                        buffer[imageDataIndex] = 255;
                        buffer[imageDataIndex + 1] = 0;
                        buffer[imageDataIndex + 2] = 255;
                        buffer[imageDataIndex + 3] = originalPatch.data[imageDataIndex + 3];

                    } else {
                        buffer[imageDataIndex] = originalPatch.data[imageDataIndex];
                        buffer[imageDataIndex + 1] = originalPatch.data[imageDataIndex + 1];
                        buffer[imageDataIndex + 2] = originalPatch.data[imageDataIndex + 2];
                        buffer[imageDataIndex + 3] = originalPatch.data[imageDataIndex + 3];
                    }
                }
            }
            let imageData = context.createImageData(IMAGE_WIDTH, IMAGE_HEIGHT);
            imageData.data.set(buffer);
            context.putImageData(imageData, 0, 0);
        }

        function darken(value) {
            return Math.max(value - DARKEN_DELTA, 0);
        }

        function areAnyNeighborsBurning(pixelX, pixelY) {
            for (let x = pixelX - 1; x <= pixelX + 1; x++) {
                for (let y = pixelY - 1; y <= pixelY + 1; y++) {
                    if (x >= 0 && x < IMAGE_WIDTH && y >= 0 && y < IMAGE_HEIGHT &&
                        (pixelX != x || pixelY != y)) {
                        if (state[x][y] == STATE_BURNING) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function populateHtml() {
            document.getElementById("MAX_HUE_DELTA").innerHTML = MAX_HUE_DELTA;
            document.getElementById("BURNABLE_AREA_HUE").innerHTML = BURNABLE_AREA_HUE;
            document.getElementById("RANDOM_BURN_RATE_PROBABILITY").innerHTML = RANDOM_BURN_RATE_PROBABILITY;
            document.getElementById("TRANSMISSION_PROBABILITY").innerHTML = TRANSMISSION_PROBABILITY;
            document.getElementById("TREE_REGENERATION_PROBABILITY").innerHTML = TREE_REGENERATION_PROBABILITY;
        }
    </script>
    <body>
        <div id="text-container">
            <div id="title">Wildfire Spread</div>
            This models wildfire spread through cellular automata. Any pixel in this image that has a hue +/- <span id="MAX_HUE_DELTA"></span> of <span id="BURNABLE_AREA_HUE"></span> is considered a tree. Any other cell is considered empty. At each timestep, a tree can ignite with a <span id="RANDOM_BURN_RATE_PROBABILITY"></span> probability. A neighbouring tree of a burning pixel can ignite with <span id="TRANSMISSION_PROBABILITY"></span>. All burning cells become burned, and all burned cells can become a tree again with <span id="TREE_REGENERATION_PROBABILITY"></span> probability. On the map, red cells are burning and purple cells represent burned areas.
        </div>
        <canvas id="canvas" width="928" height="800"/>
    </body>
    <script>
        window.onload = onLoad;
    </script>
</html>
